<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<hr />
<p>title: The Pancake Stack<br />
date: 2017-08-23 10:19:52<br />
tags:<br />
---</p>
<h1 id="the-pancake-stack">The Pancake Stack</h1>
<p>At <a href="https://engineering.gonitro.com/">Nitro</a> we've tried to embrace the idea that <a href="https://engineering.gonitro.com/can-micro-services-systems-be-simple/">simple systems</a> are key to scalable and efficient infrastructure and micro-services and help maximize innovation, velocity and trust.</p>
<p>If you havn't heard this talk by <a href="https://en.wikipedia.org/wiki/Clojure">Rich Hickey</a> please take the time to watch <a href="https://www.infoq.com/presentations/Simple-Made-Easy">this talk</a>. The points made I feel are invaluable for systems and software development. &quot;Simple&quot; is the opposite of &quot;complex&quot; which means &quot;being intertwined&quot; or &quot;being tied together&quot;. Simple is not easy but simple is something to strive for whenever possible. Simple systems are easier to understand and reason about, support and change. If there is one thing we know in this industry its that there is always something better coming out and it can be valuable to replace older components with newer more simple more efficient ones. Simple systems are good systems. Simple systems are loosely coupled.</p>
<p>All of the current infrastructure and systems stacks/platforms have there benefits and drawbacks but many attempt to solve the same functional goals. Our code has a lifecycle. Its built, deployed, tested and promoted to production. We need a system that can efficiently manage compute resources and get our code in front of our customers. The systems and platforms that can serve this lifcycle are generally composed of several components.</p>
<ul>
<li><p>Compute resources.</p></li>
<li><p>Resource managers.</p></li>
<li><p>Schedulers.</p></li>
<li><p>Service discovery.</p></li>
<li><p>Loadbalancers.</p></li>
</ul>
<p>Related system stacks that solve similar problems are the following. This is just a short list of solutions we evaluted alongside what we eventually settled on. Coreos, Docker swarm, Mesosphere, Vmware, Rancher, Heroku, ECS</p>
<p>We decided to take some of the individual components and create our own stack that serve as our infrastructure platform. Lets walk through each layer.</p>
<h3 id="cloudflare"><a href="https://www.cloudflare.com/">Cloudflare</a></h3>
<hr />
<p>Cloudflare is the first layer we use, which handles dns, ssl termination and DOS protection. In a <a href="https://en.wikipedia.org/wiki/High_availability">highly available</a> system there will be multiple ingress endpoints and cloudflare has a nice api that we use for updating dns records in the event that an aws zone goes unhealthy. We use a tool <a href="https://github.com/bparli">Ben Parli</a> developed called <a href="https://github.com/bparli/goavail">Goavail</a>. Goavail is an IP monitoring and fast DNS failover agent written in Go. More information on that can be found <a href="https://medium.com/@bparli/writing-goavail-a-cloud-monitoring-and-fast-dns-failover-agent-7c59254a5c45">here</a>.</p>
<h3 id="traefik"><a href="https://github.com/nitro/traefik">Traefik</a></h3>
<hr />
<p>After ingress traffic makes it through Cloudflare it hits our ingress termination points. We previously had used haproxy for ingress zone termination which was great but moved to a proxy called <a href="https://github.com/nitro/traefik">Traefik</a>. This made more sense as we were able to write a plugin to automatically configure backends using our service discovery tool Sidecar. Ingress traffic comes into traefik and based on the status of the internal apps Sidecar lets Traefik know where to send the traffic.</p>
<h3 id="sidecar"><a href="https://github.com/nitro/sidecar">Sidecar</a></h3>
<hr />
<ul>
<li><a href="https://github.com/nitro/haproxy-api">haproxy-api</a></li>
</ul>
<p>Sidecar is an eventually consistent service discovery platform where hosts learn about each others' state via a <a href="https://www.serf.io/docs/internals/gossip.html">gossip protocol</a>. Hosts exchange messages about which services they are running and which have gone away. Sidecar works along side the included app called haproxy-api which takes state information about the Sidecar cluster and updates a locally running copy of haproxy to handle the dynamic port mappings to service ports. In our environment all apps are shipped as Docker containers and Sidecar is designed to work best with docker although it can be used with static service mappings as well.</p>
<h3 id="sidecar-executor"><a href="https://github.com/Nitro/sidecar-executor">Sidecar-executor</a></h3>
<hr />
<ul>
<li><p><a href="https://github.com/hashicorp/vault">Vault</a></p></li>
<li><p><a href="https://www.docker.com/">Docker</a></p></li>
<li><p><a href="https://github.com/Nitro/nmesos">Nmesos</a></p></li>
</ul>
<p>Docker is how we ship our applications. Every application get delivered as a container that is configured by environment variables. We like to adhere to the <a href="https://12factor.net/">12 factor app manifesto</a> as closely as possible which reduces friction in our infrastructure and keeps things consistent. Every app is delivered as a container and each container is configured via environment variables. Scaling is accomplished by adding more concurrent containers by using our scheduler(in this case its Singularity)</p>
<p>With Sidecar and Sidecar Executor you get service health checking unified with service Discovery, regardless of which Mesos scheduler you are running. The system is completely scheduler agnostic to the extent possible.</p>
<p>Nmesos is a command line tool that leverages Singularity API to deploy services and schedule jobs in a Apache Mesos cluster.</p>
<p>Vault secures, stores, and tightly controls access to tokens, passwords, certificates, API keys, and other secrets.</p>
<h3 id="singularity"><a href="https://github.com/HubSpot/Singularity">Singularity</a></h3>
<hr />
<h3 id="mesos"><a href="http://mesos.apache.org/">Mesos</a></h3>
<hr />
<ul>
<li><a href="https://zookeeper.apache.org/">Zookeeper</a></li>
</ul>
<h3 id="ec2"><a href="https://aws.amazon.com/ec2/">Ec2</a></h3>
<hr />
<ul>
<li><p><a href="https://github.com/nitro/proviso">Proviso</a></p></li>
<li><p><a href="https://github.com/coreos/etcd">Ectd</a></p></li>
<li><p><a href="https://www.ansible.com/">Ansible</a></p></li>
</ul>
</body>
</html>
